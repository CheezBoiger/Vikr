//
// Copyright (c) Mario Garcia, Under the MIT License.
// 
#ifndef __VIKR_GL4_FRAMEBUFFER_HPP
#define __VIKR_GL4_FRAMEBUFFER_HPP


#include <graphics/framebuffer.hpp>


namespace vikr {


/**
  GL4 framebuffer.
*/
class GL4Framebuffer : public Framebuffer {
public:
  GL4Framebuffer();

  vvoid Generate() override;

  glm::vec3 GetClearColor() override { return m_clearcolor; }
  vvoid SetClearColor(glm::vec3 color) override { m_clearcolor = color; }

  vuint32 GetFramebufferId() override { return m_fbo; }
  vint32 IsComplete() override;

  vvoid Bind() override;
  vvoid Unbind() override;

  vvoid ClearDepthStencil() override;
  vvoid ClearTexture(vuint32 attachment) override;
  vvoid BindTexture(RenderTarget *target, vuint32 attachment) override;
  vvoid BindDepthStencilBuffer(Renderbuffer *rbo) override;
  vvoid DestroyFramebuffer() override;

  vint32 HasDepthStencil() override { return m_depthStencil; }
  vint32 IsMultisampled() override { return m_multisampled; }
  
  std::vector<Texture *> *GetColorAttachments() override { return &m_colorAttachments; }

  vvoid Validate() override;
  

private:

  /**
    Other texture object generated by the frame buffer.
    we use "stupid" ptrs because the textures are handled by
    our ResourceManager.
  */
  std::vector<Texture *> m_colorAttachments;

  /**
    Get the clear color for this framebuffer.
  */
  glm::vec3 m_clearcolor            = glm::vec3(0.1f, 0.1f, 0.1f);
  vbool m_depthStencil              = false;
  vbool m_multisampled              = false; // no feature yet.

  vuint32 m_fbo                     = 0;

  /**
    Reference to Renderbuffer object.
  */
  Renderbuffer *m_rbo;
}; 
} // vikr
#endif // __VIKR_